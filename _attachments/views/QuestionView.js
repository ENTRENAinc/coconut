// Generated by CoffeeScript 1.6.2
var QuestionView, _ref,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

window.SkipTheseWhen = function(argQuestions, result) {
  var disabledClass, question, questions, _i, _j, _len, _len1, _results;

  questions = [];
  argQuestions = argQuestions.split(/\s*,\s*/);
  for (_i = 0, _len = argQuestions.length; _i < _len; _i++) {
    question = argQuestions[_i];
    questions.push($(".question[data-question-name=" + question + "]"));
  }
  disabledClass = "disabled_skipped";
  _results = [];
  for (_j = 0, _len1 = questions.length; _j < _len1; _j++) {
    question = questions[_j];
    if (result) {
      _results.push(question.addClass(disabledClass));
    } else {
      _results.push(question.removeClass(disabledClass));
    }
  }
  return _results;
};

window.ResultOfQuestion = function(name) {
  var _base;

  return (typeof (_base = window.getValueCache)[name] === "function" ? _base[name]() : void 0) || null;
};

QuestionView = (function(_super) {
  __extends(QuestionView, _super);

  function QuestionView() {
    this.render = __bind(this.render, this);    _ref = QuestionView.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  QuestionView.prototype.initialize = function() {
    var _ref1;

    if ((_ref1 = Coconut.resultCollection) == null) {
      Coconut.resultCollection = new ResultCollection();
    }
    return this.autoscrollTimer = 0;
  };

  QuestionView.prototype.el = '#content';

  QuestionView.prototype.triggerChangeIn = function(names) {
    var name, _i, _len, _results,
      _this = this;

    _results = [];
    for (_i = 0, _len = names.length; _i < _len; _i++) {
      name = names[_i];
      _results.push($(".question[data-question-name=" + name + "] input, .question[data-question-name=" + name + "] select, .question[data-question-name=" + name + "] textarea").each(function(index, element) {
        var event;

        event = {
          target: element
        };
        return _this.actionOnChange(event);
      }));
    }
    return _results;
  };

  QuestionView.prototype.render = function() {
    var skipperList,
      _this = this;

    this.$el.html("    <style>      .message      {        color: grey;        font-weight: bold;        padding: 10px;        border: 1px yellow dotted;        background: yellow;        display: none;      }    </style>      <div style='position:fixed; right:5px; color:white; background-color: #333; padding:20px; display:none; z-index:10' id='messageText'>        Saving...      </div>      <h1>" + this.model.id + "</h1>      <div id='question-view'>        <form>          " + (this.toHTMLForm(this.model)) + "        </form>      </div>    ");
    this.updateSkipLogic();
    skipperList = [];
    _.each(this.model.get("questions"), function(question) {
      if (question.actionOnChange().match(/skip/i)) {
        skipperList.push(question.safeLabel());
      }
      if (question.get("action_on_questions_loaded") !== "") {
        return CoffeeScript["eval"](question.get("action_on_questions_loaded"));
      }
    });
    js2form($('form').get(0), this.result.toJSON());
    this.triggerChangeIn(skipperList);
    this.$el.find("input[type=text],input[type=number],input[type='autocomplete from previous entries'],input[type='autocomplete from list']").textinput();
    this.$el.find('input[type=radio],input[type=checkbox]').checkboxradio();
    this.$el.find('ul').listview();
    this.$el.find('select').selectmenu();
    this.$el.find('a').button();
    this.$el.find('input[type=date]').datebox({
      mode: "calbox",
      dateFormat: "%d-%m-%Y"
    });
    _.each($("input[type='autocomplete from list'],input[type='autocomplete from previous entries']"), function(element) {
      var minLength, source;

      element = $(element);
      if (element.attr("type") === 'autocomplete from list') {
        source = element.attr("data-autocomplete-options").replace(/\n|\t/, "").split(/, */);
        minLength = 0;
      } else {
        source = document.location.pathname.substring(0, document.location.pathname.indexOf("index.html")) + ("_list/values/byValue?key=\"" + (element.attr("name")) + "\"");
        minLength = 1;
      }
      return element.autocomplete({
        source: source,
        minLength: minLength,
        target: "#" + (element.attr("id")) + "-suggestions",
        callback: function(event) {
          element.val($(event.currentTarget).text());
          return element.autocomplete('clear');
        }
      });
    });
    if (this.readonly) {
      return $('input,textarea').attr("readonly", "true");
    }
  };

  QuestionView.prototype.events = {
    "blur #question-view input": "onChange",
    "change #question-view input": "onChange",
    "change #question-view select": "onChange",
    "change #question-view textarea": "onChange",
    "click #question-view button:contains(+)": "repeat",
    "click #question-view a:contains(Get current location)": "getLocation",
    "click .next_error": "runValidate"
  };

  QuestionView.prototype.runValidate = function() {
    return this.validate($('form').toObject({
      skipEmpty: false
    }));
  };

  QuestionView.prototype.onChange = function(event) {
    var $target, eventStamp;

    $target = $(event.target);
    eventStamp = $target.attr("id") + "-" + event.type + "/";
    if (eventStamp === this.oldStamp && (new Date()).getTime() < this.throttleTime + 1000) {
      return;
    }
    this.throttleTime = (new Date()).getTime();
    this.oldStamp = eventStamp;
    if ($target.attr("name") === "complete") {
      this.validate($('form').toObject({
        skipEmpty: false
      }));
    }
    this.save();
    this.updateSkipLogic();
    this.actionOnChange(event);
    return this.autoscroll(event);
  };

  QuestionView.prototype.autoscroll = function(event) {
    var $div, $target,
      _this = this;

    clearTimeout(this.autoscrollTimer);
    $target = $(event.target);
    if ($target.attr("type") === "radio") {
      $div = $target.closest(".question");
      this.$next = $div.next();
      while (this.$next.length !== 0 && this.$next.hasClass("disabled_skipped")) {
        this.$next = $(this.$next).next();
      }
      if (this.$next.length !== 0) {
        $(window).on("scroll", function() {
          $(window).off("scroll");
          return clearTimeout(_this.autoscrollTimer);
        });
        return this.autoscrollTimer = setTimeout(function() {
          $(window).off("scroll");
          return _this.$next.scrollTo();
        }, 1000);
      }
    }
  };

  QuestionView.prototype.actionOnChange = function() {
    var $divQuestion, $target, code, error, message, name, newFunction, nodeName, value;

    nodeName = $(event.target).get(0).nodeName;
    $target = nodeName === "INPUT" || nodeName === "SELECT" || nodeName === "TEXTAREA" ? $(event.target) : $(event.target).parent().parent().parent().find("input,textarea,select");
    name = $target.attr("name");
    $divQuestion = $(".question [data-question-name=" + name + "]");
    code = $divQuestion.attr("data-action_on_change");
    try {
      value = ResultOfQuestion(name);
    } catch (_error) {
      error = _error;
      if (error === "invisible reference") {
        return;
      }
    }
    if (code === "" || (code == null)) {
      return;
    }
    code = "(value) -> " + code;
    try {
      newFunction = CoffeeScript["eval"].apply(this, [code]);
      return newFunction(value);
    } catch (_error) {
      error = _error;
      name = (/function (.{1,})\(/.exec(error.constructor.toString())[1]);
      message = error.message;
      return alert("Action on change error in question " + ($divQuestion.attr('data-question-id') || $divQuestion.attr("id")) + "\n\n" + name + "\n\n" + message);
    }
  };

  QuestionView.prototype.updateSkipLogic = function() {
    return _($(".question")).each(function(question) {
      var error, message, name, result, skipLogicCode;

      question = $(question);
      skipLogicCode = question.attr("data-skip_logic");
      if (skipLogicCode === "" || (skipLogicCode == null)) {
        return;
      }
      try {
        result = CoffeeScript["eval"].apply(this, [skipLogicCode]);
      } catch (_error) {
        error = _error;
        if (error === "invisible reference") {
          result = true;
        } else {
          name = (/function (.{1,})\(/.exec(error.constructor.toString())[1]);
          message = error.message;
          alert("Skip logic error in question " + (question.attr('data-question-id')) + "\n\n" + name + "\n\n" + message);
        }
      }
      if (result) {
        return question.addClass("disabled_skipped");
      } else {
        return question.removeClass("disabled_skipped");
      }
    });
  };

  QuestionView.prototype.getLocation = function(event) {
    var question_id,
      _this = this;

    question_id = $(event.target).closest("[data-question-id]").attr("data-question-id");
    $("#" + question_id + "-description").val("Retrieving position, please wait.");
    return navigator.geolocation.getCurrentPosition(function(geoposition) {
      _.each(geoposition.coords, function(value, key) {
        return $("#" + question_id + "-" + key).val(value);
      });
      $("#" + question_id + "-timestamp").val(moment(geoposition.timestamp).format(Coconut.config.get("date_format")));
      $("#" + question_id + "-description").val("Success");
      _this.save();
      return $.getJSON("http://api.geonames.org/findNearbyPlaceNameJSON?lat=" + geoposition.coords.latitude + "&lng=" + geoposition.coords.longitude + "&username=mikeymckay&callback=?", null, function(result) {
        $("#" + question_id + "-description").val(parseFloat(result.geonames[0].distance).toFixed(1) + " km from center of " + result.geonames[0].name);
        return _this.save();
      });
    }, function(error) {
      return $("#" + question_id + "-description").val("Error: " + error);
    }, {
      frequency: 1000,
      enableHighAccuracy: true,
      timeout: 30000,
      maximumAge: 0
    });
  };

  QuestionView.prototype.validate = function(result) {
    var $question, first, isValid, name, newResult, nextButton, question, questions, _i, _len,
      _this = this;

    first = true;
    isValid = true;
    nextButton = "<button type='button' class='next_error'>Next Error</button>";
    _.chain($("input[type=radio]")).map(function(element) {
      return $(element).attr("name");
    }).uniq().map(function(radioName) {
      return result[radioName] = $("input[name=" + radioName + "]:checked").val() || "";
    });
    questions = $(".question");
    newResult = {};
    for (_i = 0, _len = questions.length; _i < _len; _i++) {
      question = questions[_i];
      $question = $(question);
      name = $(question).attr("data-question-name");
      newResult[name] = result[name];
    }
    _.each(newResult, function(value, key) {
      var $message, e, message;

      $message = ($question = $(".question[data-question-name=" + key + "]")).find(".message");
      $message.hide();
      try {
        message = _this.validateItem(value, key);
      } catch (_error) {
        e = _error;
        alert("Validate item error in " + key + "\n" + e);
        message = "";
      }
      if (message === "") {
        return;
      }
      $message.show();
      $message.html("          " + message + "          " + nextButton + "        ");
      if (first && $question.length !== 0) {
        $question.scrollTo();
        first = false;
        return isValid = false;
      }
    });
    this.completeButton(isValid);
    if (isValid) {
      $("[name=complete]").scrollTo();
    }
    return isValid;
    /*
    question = $("input[name=#{radioName}]").closest("div.question")
    required = question.attr("data-required") is "true"
    if required and not $("input[name=#{radioName}]").is(":checked") and not question.hasClass("disabled_skipped")
      labelID = question.attr("data-question-id")
      labelText = $("label[for=#{labelID}]")?.text()
      $("#validationMessage").append "'#{labelText}' is required<br/>"
    */

    /*
    unless $("#validationMessage").html() is ""
      $("input[name=complete]")?.prop("checked", false)
      return false
    else
      return true
    */

  };

  QuestionView.prototype.validateItem = function(value, question_id) {
    var error, labelText, question, questionWrapper, required, result, type, validation, validationFunctionResult, _ref1;

    if (value == null) {
      value = "";
    }
    if (!question_id) {
      return;
    }
    result = [];
    question = $("[name=" + question_id + "]");
    questionWrapper = $(".question[data-question-name=" + question_id + "]");
    if (questionWrapper.hasClass("label")) {
      return "";
    }
    type = $(questionWrapper.find("input").get(0)).attr("type");
    labelText = type === "radio" ? $("label[for=" + (question.attr("id").split("-")[0]) + "]").text() || "" : (_ref1 = $("label[for=" + (question.attr("id")) + "]")) != null ? _ref1.text() : void 0;
    required = questionWrapper.attr("data-required") === "true";
    validation = unescape(questionWrapper.attr("data-validation"));
    if (validation === "undefined") {
      validation = null;
    }
    if (questionWrapper.hasClass("disabled_skipped")) {
      return "";
    }
    if (question.find("input").length !== 0 && (type === "checkbox" || type === "radio")) {
      return "";
    }
    if (required && value === "") {
      result.push("'" + labelText + "' is required.");
    }
    if ((validation != null) && validation !== "") {
      try {
        validationFunctionResult = (CoffeeScript["eval"]("(value) -> " + validation, {
          bare: true
        }))(value);
        if (validationFunctionResult != null) {
          result.push(validationFunctionResult);
        }
      } catch (_error) {
        error = _error;
        alert("Validation error for " + question_id + " with value " + value + ": " + error);
      }
    }
    if (result.length !== 0) {
      return result.join("<br/>") + "<br/>";
    }
    return "";
  };

  QuestionView.prototype.save = _.throttle(function() {
    var currentData;

    currentData = $('form').toObject({
      skipEmpty: false
    });
    this.result.save(_.extend(currentData, {
      lastModifiedAt: moment(new Date()).format(Coconut.config.get("date_format")),
      savedBy: $.cookie('current_user')
    }), {
      success: function(model) {
        return $("#messageText").slideDown().fadeOut();
      }
    });
    return Coconut.menuView.update();
  }, 1000);

  QuestionView.prototype.completeButton = function(value) {
    if ($('[name=complete]').prop("checked") !== value) {
      return $('[name=complete]').click();
    }
  };

  QuestionView.prototype.currentKeyExistsInResultsFor = function(question) {
    var _this = this;

    return Coconut.resultCollection.any(function(result) {
      return _this.result.get(_this.key) === result.get(_this.key) && result.get('question') === question;
    });
  };

  QuestionView.prototype.repeat = function(event) {
    var button, inputElement, name, newIndex, newQuestion, questionID, re, _i, _len, _ref1;

    button = $(event.target);
    newQuestion = button.prev(".question").clone();
    questionID = newQuestion.attr("data-group-id");
    if (questionID == null) {
      questionID = "";
    }
    _ref1 = newQuestion.find("input");
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      inputElement = _ref1[_i];
      inputElement = $(inputElement);
      name = inputElement.attr("name");
      re = new RegExp("" + questionID + "\\[(\\d)\\]");
      newIndex = parseInt(_.last(name.match(re))) + 1;
      inputElement.attr("name", name.replace(re, "" + questionID + "[" + newIndex + "]"));
    }
    button.after(newQuestion.add(button.clone()));
    return button.remove();
  };

  QuestionView.prototype.toHTMLForm = function(questions, groupId) {
    var _this = this;

    if (questions == null) {
      questions = this.model;
    }
    if (questions.length == null) {
      questions = [questions];
    }
    return _.map(questions, function(question) {
      var html, index, name, newGroupId, option, options, question_id, repeatable;

      if (question.repeatable() === "true") {
        repeatable = "<button>+</button>";
      } else {
        repeatable = "";
      }
      if ((question.type() != null) && (question.label() != null) && question.label() !== "") {
        name = question.safeLabel();
        question_id = question.get("id");
        if (question.repeatable() === "true") {
          name = name + "[0]";
          question_id = question.get("id") + "-0";
        }
        if (groupId != null) {
          name = "group." + groupId + "." + name;
        }
        return "          <div             " + (question.validation() ? question.validation() ? "data-validation = '" + (escape(question.validation())) + "'" : void 0 : "") + "             data-required='" + (question.required()) + "'            class='question " + ((typeof question.type === "function" ? question.type() : void 0) || '') + "'            data-question-name='" + name + "'            data-question-id='" + question_id + "'            data-skip_logic='" + (_.escape(question.skipLogic())) + "'            data-action_on_change='" + (_.escape(question.actionOnChange())) + "'          >          <div class='message'></div>          " + (!question.type().match(/hidden/) ? "<label type='" + (question.type()) + "' for='" + question_id + "'>" + (question.label()) + " <span></span></label>" : void 0) + "          " + ((function() {
          var _i, _len, _ref1;

          switch (question.type()) {
            case "textarea":
              return "<input name='" + name + "' type='text' id='" + question_id + "' value='" + (_.escape(question.value())) + "'></input>";
            case "select":
              if (this.readonly) {
                return question.value();
              } else {
                html = "<select>";
                _ref1 = question.get("select-options").split(/, */);
                for (index = _i = 0, _len = _ref1.length; _i < _len; index = ++_i) {
                  option = _ref1[index];
                  html += "<option name='" + name + "' id='" + question_id + "-" + index + "' value='" + option + "'>" + option + "</option>";
                }
                return html += "</select>";
              }
              break;
            case "radio":
              if (this.readonly) {
                return "<input name='" + name + "' type='text' id='" + question_id + "' value='" + (question.value()) + "'></input>";
              } else {
                options = question.get("radio-options");
                return _.map(options.split(/, */), function(option, index) {
                  return "                      <label for='" + question_id + "-" + index + "'>" + option + "</label>                      <input type='radio' name='" + name + "' id='" + question_id + "-" + index + "' value='" + (_.escape(option)) + "'/>                    ";
                }).join("");
              }
              break;
            case "checkbox":
              if (this.readonly) {
                return "<input name='" + name + "' type='text' id='" + question_id + "' value='" + (_.escape(question.value())) + "'></input>";
              } else {
                return "<input style='display:none' name='" + name + "' id='" + question_id + "' type='checkbox' value='true'></input>";
              }
              break;
            case "autocomplete from list":
            case "autocomplete from previous entries":
              return "                  <!-- autocomplete='off' disables browser completion -->                  <input autocomplete='off' name='" + name + "' id='" + question_id + "' type='" + (question.type()) + "' value='" + (question.value()) + "' data-autocomplete-options='" + (question.get("autocomplete-options")) + "'></input>                  <ul id='" + question_id + "-suggestions' data-role='listview' data-inset='true'/>                ";
            case "location":
              return "                  <a data-question-id='" + question_id + "'>Get current location</a>                  <label for='" + question_id + "-description'>Location Description</label>                  <input type='text' name='" + name + "-description' id='" + question_id + "-description'></input>                  " + (_.map(["latitude", "longitude"], function(field) {
                return "<label for='" + question_id + "-" + field + "'>" + field + "</label><input readonly='readonly' type='number' name='" + name + "-" + field + "' id='" + question_id + "-" + field + "'></input>";
              }).join("")) + "                  " + (_.map(["altitude", "accuracy", "altitudeAccuracy", "heading", "timestamp"], function(field) {
                return "<input type='hidden' name='" + name + "-" + field + "' id='" + question_id + "-" + field + "'></input>";
              }).join("")) + "                ";
            case "image":
              return "<img style='" + (question.get("image-style")) + "' src='" + (question.get("image-path")) + "'/>";
            case "label":
              return "";
            default:
              return "<input name='" + name + "' id='" + question_id + "' type='" + (question.type()) + "' value='" + (question.value()) + "'></input>";
          }
        }).call(_this)) + "          </div>          " + repeatable + "        ";
      } else {
        newGroupId = question_id;
        if (question.repeatable()) {
          newGroupId = newGroupId + "[0]";
        }
        return ("<div data-group-id='" + question_id + "' class='question group'>") + _this.toHTMLForm(question.questions(), newGroupId) + "</div>" + repeatable;
      }
    }).join("");
  };

  QuestionView.prototype.updateCache = function() {
    var $qC, accessorFunction, inputs, isCheckable, name, question, selects, type, _i, _len, _ref1;

    window.questionCache = {};
    window.getValueCache = {};
    window.$questions = $(".question");
    _ref1 = window.$questions;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      question = _ref1[_i];
      name = question.getAttribute("data-question-name");
      if ((name != null) && name !== "") {
        accessorFunction = {};
        window.questionCache[name] = $(question);
        $qC = window.questionCache[name];
        selects = $("select[name=" + name + "]", $qC);
        if (selects.length === 0) {
          inputs = $("input[name=" + name + "]", $qC);
          if (inputs.length !== 0) {
            type = inputs[0].getAttribute("type");
            isCheckable = type === "radio" || type === "checkbox";
            if (isCheckable) {
              (function(name, $qC) {
                return accessorFunction = function() {
                  return $("input:checked", $qC).safeVal();
                };
              })(name, $qC);
            } else {
              (function(inputs) {
                return accessorFunction = function() {
                  return inputs.safeVal();
                };
              })(inputs);
            }
          } else {
            (function(name, $qC) {
              return accessorFunction = function() {
                return $(".textarea[name=" + name + "]", $qC).safeVal();
              };
            })(name, $qC);
          }
        } else {
          (function(selects) {
            return accessorFunction = function() {
              return selects.safeVal();
            };
          })(selects);
        }
        window.getValueCache[name] = accessorFunction;
      }
    }
    return window.keyCache = _.keys(questionCache);
  };

  QuestionView.prototype.currentKeyExistsInResultsFor = function(question) {
    var _this = this;

    return Coconut.resultCollection.any(function(result) {
      return _this.result.get(_this.key) === result.get(_this.key) && result.get('question') === question;
    });
  };

  QuestionView.prototype.repeat = function(event) {
    var button, inputElement, name, newIndex, newQuestion, questionID, re, _i, _len, _ref1;

    button = $(event.target);
    newQuestion = button.prev(".question").clone();
    questionID = newQuestion.attr("data-group-id");
    if (questionID == null) {
      questionID = "";
    }
    _ref1 = newQuestion.find("input");
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      inputElement = _ref1[_i];
      inputElement = $(inputElement);
      name = inputElement.attr("name");
      re = new RegExp("" + questionID + "\\[(\\d)\\]");
      newIndex = parseInt(_.last(name.match(re))) + 1;
      inputElement.attr("name", name.replace(re, "" + questionID + "[" + newIndex + "]"));
    }
    button.after(newQuestion.add(button.clone()));
    return button.remove();
  };

  QuestionView.prototype.getLocation = function(event) {
    var question_id,
      _this = this;

    question_id = $(event.target).closest("[data-question-id]").attr("data-question-id");
    $("#" + question_id + "-description").val("Retrieving position, please wait.");
    return navigator.geolocation.getCurrentPosition(function(geoposition) {
      _.each(geoposition.coords, function(value, key) {
        return $("#" + question_id + "-" + key).val(value);
      });
      $("#" + question_id + "-timestamp").val(moment(geoposition.timestamp).format(Coconut.config.get("date_format")));
      $("#" + question_id + "-description").val("Success");
      _this.save();
      return $.getJSON("http://api.geonames.org/findNearbyPlaceNameJSON?lat=" + geoposition.coords.latitude + "&lng=" + geoposition.coords.longitude + "&username=mikeymckay&callback=?", null, function(result) {
        $("#" + question_id + "-description").val(parseFloat(result.geonames[0].distance).toFixed(1) + " km from center of " + result.geonames[0].name);
        return _this.save();
      });
    }, function(error) {
      return $("#" + question_id + "-description").val("Error: " + error);
    }, {
      frequency: 1000,
      enableHighAccuracy: true,
      timeout: 30000,
      maximumAge: 0
    });
  };

  return QuestionView;

})(Backbone.View);

(function($) {
  $.fn.scrollTo = function(speed, callback) {
    var e;

    if (speed == null) {
      speed = 500;
    }
    try {
      $('html, body').animate({
        scrollTop: $(this).offset().top + 'px'
      }, speed, null, callback);
    } catch (_error) {
      e = _error;
      console.log("error", e);
      console.log("Scroll error with 'this'", this);
    }
    return this;
  };
  return $.fn.safeVal = function() {
    if (this.is(":visible")) {
      return (this.val() || '').trim();
    } else {
      return null;
    }
  };
})($);

/*
//@ sourceMappingURL=QuestionView.map
*/
