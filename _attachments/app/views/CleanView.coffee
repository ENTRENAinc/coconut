class CleanView extends Backbone.View
  initialize: ->
    @question = new Question()

  el: '#content'

  render: (args) =>
    @args = args

    console.log @args

    if @args is "undo"
      throw "Must be admin" unless User.currentUser.username() is "admin"
      rc = new ResultCollection()
      rc.fetch
        include_docs: true
        success: ->
          changed_results = rc.filter  (result) ->
            (result.get("user") is "reports") and (result.get("question") is "Household Members")
          _.each changed_results, (result) ->
            $.couch.db("zanzibar").openDoc result.id,
              revs_info: true
            ,
              success: (doc) ->
                console.log doc.HeadofHouseholdName
                $.couch.db("zanzibar").openDoc result.id,
                  rev: doc._revs_info[1].rev #1 gives us the previous revision
                ,
                  success: (previousDoc) ->
                    newDoc = previousDoc
                    newDoc._rev = doc._rev
                    result.save newDoc

      return

    @total = 0
    @$el.html "
      <h1>The following data requires cleaning</h1>
      <h2>Dates (<span id='total'></span>)</h2>
      <a href='#clean/apply_dates'<button>Apply Recommended Date Fixes</button></a>
      <div id='dates'>
        <table>
        </table>
      </div>
      <h2>CaseIDS (<span id='total'></span>)</h2>
      <a href='#clean/apply_caseIDs'<button>Apply Recommended CaseID Fixes</button></a>
      <div id='caseIDs'>
        <table>
          <thead>
            <th>Current</th>
            <th>Recommendation</th>
          </thead>
          <tbody>
        </table>
      </div>
    "
    # 3 options: edit partials, edit complete, create new
    @resultCollection = new ResultCollection
    @resultCollection.fetch
      include_docs: true
      success: =>
        @searchForDates()
        @searchForManualCaseIDs()

  searchForManualCaseIDs: ->
    @resultCollection.each (result) =>
      _.each _.keys(result.attributes), (key) =>
        if key.match(/MalariaCaseID/i)
          caseID = result.get(key)
          if caseID?
            unless caseID.match(/[A-Z][A-Z][A-Z]\d\d\d/)
              recommendedChange = caseID.replace(/[\ \.\-\/_]/,"")
              recommendedChange = recommendedChange.toUpperCase()

              if recommendedChange.match(/[A-Z][A-Z][A-Z]\d\d\d/)
                if @args is "apply_caseIDs"
                  throw "Must be admin" unless User.currentUser.username() is "admin"
                  result.save key,recommendedChange
              else
                recommendedChange = "Fix manually"

              $("#caseIDs tbody").append "
                <tr>
                  <td>#{caseID}</td>
                  <td>#{recommendedChange}</td>
                </tr>
              "


  searchForDates: ->
    @resultCollection.each (result) =>
      _.each _.keys(result.attributes), (key) =>
        if key.match(/date/i)
          date = result.get(key)
          if date?
            @total++
            cleanedDate = @cleanDate(date)
            unless cleanedDate[1] is "No action recommended"
              $("#dates table").append "
                <tr>
                  <td><a href='#show/case/#{result.get("MalariaCaseID")}'>#{result.get("MalariaCaseID")}</a></td>
                  <td>#{key}</td>
                  <td>#{date}</td>
                  <td>#{cleanedDate[0]}</td>
                  <td>#{cleanedDate[1]}</td>
                </tr>
              "
              if @args is "apply_dates" and cleanedDate[0]
                throw "Must be admin" unless User.currentUser.username() is "admin"
                result.save key,cleanedDate[0]

  cleanDate: (date) ->
    dateMatch = date.match /^(\d+)([ -/])(\d+)([ -/])(\d+)$/
    if dateMatch
      first = dateMatch[1]
      second = dateMatch[3]
      third = dateMatch[5]
      if second.match /201\d/
        return [null, "Invalid year"]

      if first.match /201\d/
        year = first
        if dateMatch[2] != "-"
          day = second
          month = third
          return [@format(year,month,day), "Non dash separators, not generated by tablet, can assume yy,dd,mm"]
        else
          return [null, "No action recommended"]

      else if third.match /201\d/
        day = first
        month = second
        year = third
        return [@format(year,month,day), "Year last, not generated by tablet, can assume dd,mm,yy"]
    else
      return [null, "Can't find a date"]

  format: (year,month,day) ->
    year = parseInt(year,10)
    month = parseInt(month,10)
    day = parseInt(day,10)
    month = "0#{month}" if month < 10
    day = "0#{day}" if day < 10
    return "#{year}-#{month}-#{day}"
